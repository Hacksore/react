import _extends from '@babel/runtime/helpers/esm/extends';
import _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';
import memoizeOne from 'memoize-one';
import { createElement, PureComponent } from 'react';
import { flushSync as flushSync$1 } from 'react-dom';
import { unstable_runWithPriority, unstable_IdlePriority } from 'scheduler';

var cachedDisplayLockingSupport = null; // Detects browser support Display Locking API:
// https://github.com/WICG/display-locking

function detectDisplayLockingSupport() {
  if (typeof cachedDisplayLockingSupport === null) {
    var div = document.createElement('div');
    cachedDisplayLockingSupport = typeof div.updateRendering === 'function';
  }

  return cachedDisplayLockingSupport;
}

// Animation frame based implementation of setTimeout.
// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js
var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
var now = hasNativePerformanceNow ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay) {
  var start = now();

  function tick() {
    if (now() - start >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }

  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}

// Polyfill flushSync for older React versions.
var flushSync = typeof flushSync$1 === 'function' ? flushSync$1 : function (callback) {
  return callback();
};
var DEFAULT_MAX_NUM_PRERENDER_ROWS = 25;

var defaultItemKey = function defaultItemKey(index) {
  return index;
};

var RESET_POINTER_EVENTS_DEBOUNCE_INTERVAL = 150;
var hiddenDOMProperties = {
  hidden: true
};
var invisibleDOMProperties = {
  hidden: true,
  rendersubtree: 'invisible'
};
var visibleDOMProperties = {
  rendersubtree: 'visible'
};

var List =
/*#__PURE__*/
function (_PureComponent) {
  _inheritsLoose(List, _PureComponent);

  // Always use explicit constructor for React components.
  // It produces less code after transpilation. (#26)
  // eslint-disable-next-line no-useless-constructor
  function List(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    _this._innerRef = void 0;
    _this._isDisplayLockingSupported = detectDisplayLockingSupport();
    _this._outerRef = void 0;
    _this._prerenderOverscanRowsTimeoutID = null;
    _this._resetPointerEventsTimeoutID = null;
    _this._callOnItemsDisplayed = void 0;
    _this._callOnItemsDisplayed = memoizeOne(function (startIndex, stopIndex) {
      var onItemsDisplayed = _this.props.onItemsDisplayed;

      if (typeof onItemsDisplayed === 'function') {
        onItemsDisplayed(startIndex, stopIndex);
      }
    });
    _this._getItemStyleCache = void 0;
    _this._getItemStyleCache = memoizeOne(function (itemSize) {
      return {};
    });

    _this._innerRefSetter = function (ref) {
      var innerRef = _this.props.innerRef;
      _this._innerRef = ref;

      if (typeof innerRef === 'function') {
        innerRef(ref);
      } else if (innerRef != null && typeof innerRef === 'object' && innerRef.hasOwnProperty('current')) {
        innerRef.current = ref;
      }
    };

    _this._onScroll = function (event) {
      var _event$currentTarget = event.currentTarget,
          clientHeight = _event$currentTarget.clientHeight,
          scrollHeight = _event$currentTarget.scrollHeight,
          scrollTop = _event$currentTarget.scrollTop;
      var onScroll = _this.props.onScroll; // Scroll events should be processed as quickly as possible, even in concurrent mode, to avoid checkerboarding.
      // Wrapping the onScroll callback as well ensures that any rendering it schedules is included in this batch.

      flushSync(function () {
        if (typeof onScroll === 'function') {
          onScroll(event);
        }

        _this.setState(function (prevState) {
          // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.
          var maxScrollOffset = Math.min(scrollTop, scrollHeight - clientHeight);
          var safeScrollTop = Math.max(0, maxScrollOffset);

          if (prevState.scrollTop === safeScrollTop) {
            // Scroll position may have been updated by cDM/cDU,
            // In which case we don't need to trigger another render,
            return null;
          }

          var _this$_getVisibleIndi = _this._getVisibleIndicesForOffset(safeScrollTop),
              startIndex = _this$_getVisibleIndi[0],
              stopIndex = _this$_getVisibleIndi[1];

          var isSubset = startIndex >= prevState.startIndex && stopIndex <= prevState.stopIndex;
          return {
            scrollTop: safeScrollTop,
            scrollUpdateWasRequested: true,
            startIndex: isSubset ? prevState.startIndex : startIndex,
            stopIndex: isSubset ? prevState.stopIndex : stopIndex
          };
        });
      });
    };

    _this._outerRefSetter = function (ref) {
      var outerRef = _this.props.outerRef;
      _this._outerRef = ref;

      if (typeof outerRef === 'function') {
        outerRef(ref);
      } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {
        outerRef.current = ref;
      }
    };

    _this._prerenderOverscanRows = function () {
      _this._prerenderOverscanRowsTimeoutID = null;
      unstable_runWithPriority(unstable_IdlePriority, function () {
        _this.setState(function (prevState) {
          var _this$props = _this.props,
              itemCount = _this$props.itemCount,
              _this$props$maxNumPre = _this$props.maxNumPrerenderRows,
              maxNumPrerenderRows = _this$props$maxNumPre === void 0 ? DEFAULT_MAX_NUM_PRERENDER_ROWS : _this$props$maxNumPre;

          var _this$_getVisibleIndi2 = _this._getVisibleIndicesForOffset(prevState.scrollTop),
              startIndex = _this$_getVisibleIndi2[0],
              stopIndex = _this$_getVisibleIndi2[1];

          var numRowsPerViewport = stopIndex - startIndex;
          var numPrerenderRows = Math.min(numRowsPerViewport, maxNumPrerenderRows);
          var nextStartIndex = Math.max(0, startIndex - numPrerenderRows);
          var nextStopIndex = Math.min(itemCount - 1, stopIndex + numPrerenderRows);

          if (prevState.startIndex === nextStartIndex && prevState.stopIndex === nextStopIndex) {
            return null;
          }

          return {
            startIndex: nextStartIndex,
            stopIndex: nextStopIndex
          };
        });
      });
    };

    _this._refSetterForDisplayLockingOnly = function (ref) {
      // If the browser supports the display locking API,
      // tell it to do work in the background to prepare the display locked row.
      if (_this._isDisplayLockingSupported) {
        if (ref != null && ref.hidden) {
          ref.updateRendering();
        }
      }
    };

    _this._resetPointerEvents = function () {
      _this._resetPointerEventsTimeoutID = null; // Resetting pointer events doesn't require a cascading render.

      if (_this._innerRef != null && _this._innerRef.style.pointerEvents === 'none') {
        _this._innerRef.style.pointerEvents = 'auto';
      } // Clear style cache after scrolling has stopped.
      // This enables us to cache during the most perfrormance sensitive times (when scrolling)
      // while also preventing the cache from growing unbounded.


      _this._getItemStyleCache(-1);
    };

    var initialScrollOffset = props.initialScrollOffset;

    var _scrollTop = typeof initialScrollOffset === 'number' ? initialScrollOffset : 0;

    var _this$_getVisibleIndi3 = _this._getVisibleIndicesForOffset(_scrollTop),
        _startIndex = _this$_getVisibleIndi3[0],
        _stopIndex = _this$_getVisibleIndi3[1];

    _this.state = {
      scrollTop: _scrollTop,
      scrollUpdateWasRequested: typeof initialScrollOffset === 'number',
      startIndex: _startIndex,
      stopIndex: _stopIndex
    };
    return _this;
  }

  var _proto = List.prototype;

  _proto.scrollTo = function scrollTo(scrollTop) {
    var _this2 = this;

    scrollTop = Math.max(0, scrollTop);
    this.setState(function (prevState) {
      if (prevState.scrollTop === scrollTop) {
        return null;
      }

      var _this2$_getVisibleInd = _this2._getVisibleIndicesForOffset(scrollTop),
          startIndex = _this2$_getVisibleInd[0],
          stopIndex = _this2$_getVisibleInd[1];

      var isSubset = startIndex >= prevState.startIndex && stopIndex <= prevState.stopIndex;
      return {
        scrollTop: scrollTop,
        scrollUpdateWasRequested: true,
        startIndex: isSubset ? prevState.startIndex : startIndex,
        stopIndex: isSubset ? prevState.stopIndex : stopIndex
      };
    });
  };

  _proto.scrollToItem = function scrollToItem(index, align) {
    if (align === void 0) {
      align = 'smart';
    }

    var _this$props2 = this.props,
        height = _this$props2.height,
        itemCount = _this$props2.itemCount,
        itemSize = _this$props2.itemSize;
    var scrollTop = this.state.scrollTop;
    index = Math.max(0, Math.min(index, itemCount - 1));
    var lastItemOffset = Math.max(0, itemCount * itemSize - height);
    var maxOffset = Math.min(lastItemOffset, index * itemSize);
    var minOffset = Math.max(0, index * itemSize - height + itemSize);

    if (align === 'smart') {
      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
        align = 'minimum';
      } else {
        align = 'center';
      }
    }

    switch (align) {
      case 'start':
        this.scrollTo(maxOffset);
        break;

      case 'end':
        this.scrollTo(minOffset);
        break;

      case 'center':
        // "Centered" offset is usually the average of the min and max.
        // But near the edges of the list, this doesn't hold true.
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);

        if (middleOffset < Math.ceil(height / 2)) {
          this.scrollTo(0); // near the beginning
        } else if (middleOffset > lastItemOffset + Math.floor(height / 2)) {
          this.scrollTo(lastItemOffset); // near the end
        } else {
          this.scrollTo(middleOffset);
        }

        break;

      case 'minimum':
      default:
        if (scrollTop >= minOffset && scrollTop <= maxOffset) {
          this.scrollTo(scrollTop);
        } else if (scrollTop < minOffset) {
          this.scrollTo(minOffset);
        } else {
          this.scrollTo(maxOffset);
        }

        break;
    }
  };

  List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    if (process.env.NODE_ENV !== 'production') {
      validateProps(nextProps);
    }

    return null;
  };

  _proto.componentDidMount = function componentDidMount() {
    this._commitHook();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this._commitHook();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this._resetPointerEventsTimeoutID !== null) {
      cancelTimeout(this._resetPointerEventsTimeoutID);
    }

    if (this._prerenderOverscanRowsTimeoutID !== null) {
      cancelTimeout(this._prerenderOverscanRowsTimeoutID);
    }
  };

  _proto.render = function render() {
    var _this$props3 = this.props,
        className = _this$props3.className,
        height = _this$props3.height,
        innerElementType = _this$props3.innerElementType,
        itemCount = _this$props3.itemCount,
        _this$props3$itemKey = _this$props3.itemKey,
        itemKey = _this$props3$itemKey === void 0 ? defaultItemKey : _this$props3$itemKey,
        itemSize = _this$props3.itemSize,
        itemRenderer = _this$props3.itemRenderer,
        outerElementType = _this$props3.outerElementType,
        style = _this$props3.style,
        width = _this$props3.width;
    var _this$state = this.state,
        scrollTop = _this$state.scrollTop,
        startIndex = _this$state.startIndex,
        stopIndex = _this$state.stopIndex;

    var _this$_getVisibleIndi4 = this._getVisibleIndicesForOffset(scrollTop),
        visibleStartIndex = _this$_getVisibleIndi4[0],
        visibleStopIndex = _this$_getVisibleIndi4[1];

    var items = [];

    if (itemCount > 0) {
      var itemStyleCache = this._getItemStyleCache(itemSize);

      for (var _index = startIndex; _index <= stopIndex; _index++) {
        var isHidden = _index < visibleStartIndex || _index > visibleStopIndex;
        var isDisplayLocked = this._isDisplayLockingSupported && isHidden;
        var styleKey = isDisplayLocked ? _index + "!" : _index;

        var _style = void 0;

        if (itemStyleCache.hasOwnProperty(styleKey)) {
          _style = itemStyleCache[styleKey];
        } else {
          _style = {
            position: 'absolute',
            left: 0,
            top: _index * itemSize,
            height: itemSize,
            width: '100%'
          };

          if (isDisplayLocked) {
            // Override default hidden style of display:none,
            // because it would interfere with the renderSubtree API.
            _style.display = 'block';
          }

          itemStyleCache[styleKey] = _style;
        }

        var domProperties = void 0;

        if (this._isDisplayLockingSupported) {
          domProperties = isHidden ? invisibleDOMProperties : visibleDOMProperties;
        } else {
          domProperties = isHidden ? hiddenDOMProperties : null;
        }

        items.push(itemRenderer({
          domProperties: domProperties,
          key: itemKey(_index),
          index: _index,
          ref: isDisplayLocked ? this._refSetterForDisplayLockingOnly : undefined,
          style: _style
        }));
      }
    }

    return createElement(outerElementType || 'div', {
      className: className,
      onScroll: this._onScroll,
      ref: this._outerRefSetter,
      style: _extends({
        position: 'relative',
        height: height,
        width: width,
        overflow: 'auto',
        WebkitOverflowScrolling: 'touch',
        willChange: 'transform'
      }, style)
    }, createElement(innerElementType || 'div', {
      children: items,
      ref: this._innerRefSetter,
      style: {
        height: itemSize * itemCount,
        width: '100%',
        // Note that it's more efficient to always render with pointer events disabled,
        // and avoid tracking an extra bit of "is scrolling" state.
        // After commit, we'll reset the style on a debounced.
        pointerEvents: 'none'
      }
    }));
  };

  _proto._commitHook = function _commitHook() {
    var _this$props4 = this.props,
        itemCount = _this$props4.itemCount,
        prerenderMode = _this$props4.prerenderMode;
    var _this$state2 = this.state,
        scrollTop = _this$state2.scrollTop,
        scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;

    if (scrollUpdateWasRequested && this._outerRef != null) {
      var outerRef = this._outerRef;
      outerRef.scrollTop = scrollTop;
    }

    if (itemCount > 0) {
      var _this$_getVisibleIndi5 = this._getVisibleIndicesForOffset(scrollTop),
          _startIndex2 = _this$_getVisibleIndi5[0],
          _stopIndex2 = _this$_getVisibleIndi5[1];

      this._callOnItemsDisplayed(_startIndex2, _stopIndex2);
    }

    this._resetPointerEventsDebounced(); // Schedule an update to pre-render rows at idle priority.
    // This will make the list more responsive to subsequent scrolling.


    if (typeof unstable_runWithPriority === 'function') {
      if (prerenderMode === 'idle') {
        this._prerenderOverscanRows();
      } else if (prerenderMode === 'idle+debounce') {
        this._prerenderOverscanRowsDebounced();
      }
    }
  }; // Lazily create and cache item styles while scrolling,
  // So that pure component sCU will prevent re-renders.
  // We maintain this cache, and pass a size prop rather than index,
  // So that List can clear cached styles and force item re-render if necessary


  _proto._getVisibleIndicesForOffset = function _getVisibleIndicesForOffset(scrollTop) {
    var _this$props5 = this.props,
        height = _this$props5.height,
        itemCount = _this$props5.itemCount,
        itemSize = _this$props5.itemSize;

    if (itemCount === 0) {
      return [0, 0];
    }

    var startIndex = Math.max(0, Math.min(itemCount - 1, Math.floor(scrollTop / itemSize)));
    var firstItemOffset = startIndex * itemSize;
    var numVisibleItems = Math.ceil((height + scrollTop - firstItemOffset) / itemSize);
    var stopIndex = Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive
    )); // Overscan by one item in each direction so that tab/focus works.
    // If there isn't at least one extra item, tab loops back around.

    return [Math.max(0, startIndex - 1), Math.max(0, Math.min(itemCount - 1, stopIndex + 1))];
  };

  _proto._prerenderOverscanRowsDebounced = function _prerenderOverscanRowsDebounced() {
    if (this._prerenderOverscanRowsTimeoutID !== null) {
      cancelTimeout(this._prerenderOverscanRowsTimeoutID);
    }

    this._prerenderOverscanRowsTimeoutID = requestTimeout(this._prerenderOverscanRows, RESET_POINTER_EVENTS_DEBOUNCE_INTERVAL);
  };

  _proto._resetPointerEventsDebounced = function _resetPointerEventsDebounced() {
    if (this._resetPointerEventsTimeoutID !== null) {
      cancelTimeout(this._resetPointerEventsTimeoutID);
    }

    this._resetPointerEventsTimeoutID = requestTimeout(this._resetPointerEvents, RESET_POINTER_EVENTS_DEBOUNCE_INTERVAL);
  };

  return List;
}(PureComponent);
var validateProps = null;

if (process.env.NODE_ENV !== 'production') {
  validateProps = function validateProps(_ref) {
    var height = _ref.height,
        itemRenderer = _ref.itemRenderer,
        itemSize = _ref.itemSize;

    if (typeof itemRenderer !== 'function') {
      throw Error('An invalid "itemRenderer" prop has been specified. ' + 'Value should be a function that returns React elements. ' + ("\"" + (itemRenderer === null ? 'null' : typeof itemRenderer) + "\" was specified."));
    }

    if (typeof itemSize !== 'number') {
      throw Error('An invalid "itemSize" prop has been specified. ' + 'Value should be a number. ' + ("\"" + (itemSize === null ? 'null' : typeof itemSize) + "\" was specified."));
    }

    if (typeof height !== 'number') {
      throw Error('An invalid "height" prop has been specified. ' + 'Lists must specify a number for height. ' + ("\"" + (height === null ? 'null' : typeof height) + "\" was specified."));
    }
  };
}

export { List as SimpleList };
//# sourceMappingURL=index.esm.js.map
